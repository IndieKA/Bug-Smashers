
/************************************************************
 * When making an app, follow these rules:
 * 1. Make sure the app doesn't exceed over 600 lines of code.
 * 2. Make the game a good game, something that isn't boring!
 * 3. DO NOT SPACE YOUR PROGRAM. 
 ************************************************************/
 /***************************
 * The credits section for iPad apps: (People's things I used.)
 * MAIN CREDIT: coderman64 (For the app function
 * Other credits:
 * Ben Rowan: For 'Painter Pro 2000'.
 * Matthias: For 'XYGraph'
 * Will Early: For 'SpacePath'
 * Akshat An and Timestopper: For 'Emoticon Jumper' levels.
/*```````````` ```````````````USE LINK BELOW FOR BEST VIEWING EXPERIENCE```````````````````````````*
 *```https://www.khanacademy.org/computer-programming/ipad/4971592776024064?width=740&height=500```*
 *`````````````````````````````````````````````````````````````````````````````````````````````````*/
frameCount=0;
var KHANFLICT = (function() {
    /**
     * Khanflict utility for Khan Academy
     * (c) 2015 JPG2000
     * This code is released under standard and current KA license
    **/
    //A self executing function to shorten lookups have pseudo-private variables, and so our variables don't pollute the global scope
    var dat = {};
    
    var callbacks = {
        draw: [],
        mouseClicked: [],
        mousePressed: [],
        mouseReleased: [],
        mouseMoved: [],
        mouseDragged: [],
        mouseOver: [],
        mouseOut: [],
        keyPressed: [],
        keyReleased: [],
        keyTyped: []
    };
    
    var initCallbackSetter = function(cbid) {
        //This function defines a setter function for a non existent property on dat with the name of some KA defined callback
        Object.defineProperty(dat, cbid, {
            set: function(v) {
                if (typeof v === "function") {
                    callbacks[cbid].push(v);
                } else if (typeof v.call === "function") {
                    callbacks[cbid].push(v.call);
                } else {
                    println("Oh noes! Invalid callback provided for " + cbid + "! Please use only functions and objects with a call function!");
                }
            }
        });
    };
    
    (function() {
        //Self executing function so that the callbackNames variable isn't used anywhere other than the loop and is thrown away after the loop terminates
        var callbackNames = Object.keys(callbacks);
        for(var i = 0; i < callbackNames.length; i ++) {
            initCallbackSetter(callbackNames[i]);
        }
    })();
    
    draw = function() {
        if(!this.loadPixels) {
            return;
        }
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.draw.length; i ++) {
            callbacks.draw[i]();
        }
    };
    
    mouseClicked = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseClicked.length; i ++) {
            callbacks.mouseClicked[i]();
        }
    };
    
    mousePressed = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mousePressed.length; i ++) {
            callbacks.mousePressed[i]();
        }
    };
    
    mouseReleased = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseReleased.length; i ++) {
            callbacks.mouseReleased[i]();
        }
    };
    
    mouseMoved = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseMoved.length; i ++) {
            callbacks.mouseMoved[i]();
        }
    };
    
    mouseDragged = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseDragged.length; i ++) {
            callbacks.mouseDragged[i]();
        }
    };
    
    mouseOver = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseOver.length; i ++) {
            callbacks.mouseOver[i]();
        }
    };
    
    mouseOut = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.mouseOut.length; i ++) {
            callbacks.mouseOut[i]();
        }
    };
    
    keyPressed = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.keyPressed.length; i ++) {
            callbacks.keyPressed[i]();
        }
    };
    
    keyReleased = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.keyReleased.length; i ++) {
            callbacks.keyReleased[i]();
        }
    };
    
    keyTyped = function() {
        //Magical KA callbacks!
        for (var i = 0; i < callbacks.keyTyped.length; i ++) {
            callbacks.keyTyped[i]();
        }
    };
    
    
    return dat;
})();
var keys = [];
var keyPressed = function() {
    keys[keyCode] = true;
};
var keyReleased = function() {
    keys[keyCode] = false;
};
var mouseIn = function(x, y, w, h) {
    if (mouseX > x && mouseY > y && mouseX < x + w && mouseY < y + h) {
        return true;
    } else {
        return false;
    }
};
var bckgrnd = function(clr,app) {
    
    colorMode(RGB);
    fill(clr);
    if(!app){
        rect(0,0,width,height);
    }
    else{
        rect(0,0,app.width,app.height);
    }
    //ellipse(-10+(width+20)/2,-10+(height+20)/2,width+20,height+20);
};
var geo={
    megaNot: function(ky,list) {
        var bool = true;
        for(var i = 0;i<list.length;i++){
            if(ky === list[i]){bool=false;}
        }
        return bool;
    },
    radius:0,
    stroke:0.5,
    colorFn:function(){
        if(this.stroke>0){ strokeWeight(this.stroke);}
        else{noStroke();}
        if(typeof this.strokeColor === "number"){stroke(this.strokeColor);}
        if((typeof this.fillColor) === "number"){fill(this.fillColor);}
        if(typeof this.strokeColor === "number"){stroke(this.strokeColor);}
        
    },
    nLine: function(gPoint1,gPoint2,color){
        this.colorFn();
        if(color){stroke(color);}
        line(gPoint1[0],gPoint1[1],gPoint2[0],gPoint2[1]);  
    },
    nQuad: function(gPoint1,gPoint2,gPoint3,gPoint4){
        this.colorFn();
        quad(gPoint1[0],gPoint1[1],gPoint2[0],gPoint2[1], gPoint3[0],gPoint3[1],gPoint4[0],gPoint4[1]);
    },
    nRect: function(gPoint1,gPoint2,txt,txtSize){
        this.colorFn();
        rect(gPoint1[0],gPoint1[1],abs(gPoint1[0]-gPoint2[0]),abs(gPoint1[1]-gPoint2[1]));
        if(txt){fill(txt[1]||0);
            if(txtSize){textSize(txtSize);}
            textAlign(CENTER,TOP);
            text(txt[0],gPoint1[0],gPoint1[1],abs(gPoint1[0]-gPoint2[0]),abs(gPoint1[1]-gPoint2[1]));
        }
    },
    nTri:  function(gPoint1,gPoint2,gPoint3){
        this.colorFn();
        this.nQuad(gPoint1,gPoint2,gPoint3,gPoint1);
    }
    
};
var WINDOWSTORAGE;
var windows = []; 
frameRate(80);
var window = function(config) {
    windows.unshift(this);
    
    this.winX = config.winX || 20;
    this.winY = config.winY || 20;
    this.wid  = config.wid || 180;
    this.hei  = config.hei || 180;
    this.btnSize = config.btnSize || 20;
    this.check = function(y){
        var a ="";
        if(this.paused.minimized===false){
        this.windowSelected = mouseX>=this.winX && mouseY>=this.winY&&(mouseX<(this.winX+this.wid))&&(mouseY<(this.winY+this.hei+this.btnSize));
        this.bottomWinSelected = mouseX>=this.winX+3 && mouseY>=this.winY+this.btnSize && mouseX<(this.winX+this.wid-6)&& mouseY<(this.winY+this.hei-this.btnSize);
        var c = this.windowSelected&&(!this.bottomWinSelected);
        switch(y){
            case 1: a= this.windowSelected;    break;
            case 2: a= this.bottomWinSelected; break;
            default:a= c;break;
        }
        }
        else{
            a=false;
        }
        return a;
    };
    this.selected=false;
    this.format = config.format || function() {fill(255, 0, 0,180);};
    this.runtimes= 0;
    this.variables={};
    this.yar = function(varName,value) {
        this.variables[varName]=value;
    };
    this.defaultDraw = function() {
        var winX=this.winX||20;
        var winY=this.winY||20;
        var wid=this.wid||180;
        var hei=this.hei||180;
        var btnSize=this.btnSize||20;
        var txtArr=[null,["×",255],["▧",255],"-"];
        var formatBtn=function(x,o){
            switch(x){
                case 1: fill(91, 91, 252,105);
                        break;
                case 2: fill(72, 240, 74,105);
                        break;
                case 3: fill(255, 255, 0,105);
                        break;
            }
            textSize(17);
            if(!o){
                geo.nRect([wid-btnSize*x+(winX),winY],[wid-btnSize*(x-1)+(winX),winY+btnSize],txtArr[x]);
            }
            else{
                geo.nRect([wid-btnSize*x+(winX),o],[wid-btnSize*(x-1)+(winX),o+btnSize],txtArr[x]);
            }
        };
        for(var _btns=1;_btns<4;_btns++){
                if(mouseIn(this.wid-this.btnSize*_btns+(this.winX),this.winY,this.btnSize,this.btnSize)&&mouseIsPressed){
                    switch(_btns){
                        case 3: this.paused.minimized=true;break;
                        case 2: this.paused.maximized=!this.paused.maximized;
                        if(this.paused.maximized){
                            this.paused.wid=this.wid; 
                            this.paused.hei=this.hei; 
                            this.paused.winX=this.winX;
                            this.paused.winY=this.winY;
                            this.wid=min(width-this.btnSize,height-this.btnSize*2);
                            this.hei=this.wid;
                            this.winX=(width-this.wid)/2; this.winY=0;
                        }else{
                            this.wid=this.paused.wid; 
                            this.hei=this.paused.hei; 
                            this.winX=this.paused.winX;
                            this.winY=this.paused.winY;
                        }
                        break;
                        case 1: this.paused.minimized=true;this.variables={};this.runtimes=0;break;
                    }
            }
            
        }
        winX=this.winX||20;
        winY=this.winY||20;
        wid=this.wid||180;
        hei=this.hei||180;
        btnSize=this.btnSize||20;
        if(this.paused.maximized===true){
            this.format();
            geo.nRect([winX,0],[winX+wid,0+hei+btnSize+btnSize]);
            formatBtn(1,-this.btnSize/(10*height/400));
            formatBtn(2,-this.btnSize/(10*height/400));
            formatBtn(3,-this.btnSize/(10*height/400));
        }
        else{
            this.format();
            geo.nRect([winX,winY],[winX+wid,winY+hei+btnSize+btnSize]);
            formatBtn(1);
            formatBtn(2);
            formatBtn(3);
        }
        /*
        
            stroke(0, 0, 0,120);
            this.format();
            
            if(!this.paused.maximized){}
            geo.nRect([winX,winY],[winX+wid,winY+hei+btnSize+btnSize]); 
            //geo.nRect([20,20],[200,200]);
            
            fill(91, 91, 252,105);
            textSize(17);
            geo.nRect([wid-btnSize*1+(winX),winY],[wid-btnSize*0+(winX),winY+btnSize],["×",255]);
            //geo.nRect([180,20],[200,40],"×");
            
            fill(72, 240, 74,105);
            geo.nRect([wid-btnSize*2+(winX),winY],[wid-btnSize*1+(winX),winY+btnSize],["▧",255]);
            //geo.nRect([160,20],[180,40],"▧");
            
            fill(255, 255, 0,105);
            geo.nRect([wid-btnSize*3+(winX),winY],[wid-btnSize*2+(winX),winY+btnSize],"-");
            //geo.nRect([140,20],[160,40],"-");*/
            fill(0, 0, 0);
    };
    this.program = config.program ||function() {};
    this.snaps=true;
    this.paused=config.paused ||{
        minimized:true,
        maximized:false
    };
    this.width=config.width||400;
    this.height=config.height||400;
    
    this.draw= function() {
        if(this.paused.minimized!==undefined&&this.paused.minimized===false)
        {
            this.defaultDraw();
            pushMatrix();
            translate(this.winX+3,this.winY+3+this.btnSize);
            scale((this.wid-6)/this.width,(this.hei-6)/this.height);
            if (typeof this.program === "function"){
                var aFun= function() {
                    this.width=400;this.height=400;
                };
                this.program(aFun);
                if(this.snaps===true){
                    this.snap=get(this.winX+3,this.winY+this.btnSize+3,this.wid-6,this.hei-6);
                }
                this.runtimes+=1;
                if(this.runtimes>=this.MAX_VALUE-2){this.runtimes=0;}
            }
        popMatrix();
        }
    };
};
var topText= function(wind,txt,clr,size){
    var a ="";
    if(typeof txt !=="string"){
        a=txt[0];
    }
    else{
        a=txt;
    }
    if(wind.paused.minimized!==true){
            popMatrix();
            popMatrix();
            pushMatrix();
            textSize(13);
            fill(0);
            translate(wind.winX+2,0);
            if(clr!==undefined){
                fill(clr);
            }
            if(size!==undefined){
                scale(size,1);
            }
            textAlign(LEFT,TOP);
            if(typeof txt !=="string"){
                text(txt[0],0,wind.winY+2);
                text(txt[1],0,wind.hei+wind.winY+wind.btnSize);
            }
            else{
                text(txt,0,wind.winY+2);
            }
            
            popMatrix();
    }
    wind.name=a;
};
var win1 = new window({
    hei: 180,
    winY: 21,
    format: function() {
        topText(this,["WGraphs","by Nate"],color(0, 0, 0));
        fill(235, 0, 0,180); stroke(0,0,0); strokeWeight(0.5);
    },
    init:false,
    program: function(){
        if(this.runtimes>0){this.snaps=false;image(this.snap,0,0,this.width,this.height);}
        else{
            // draw the axes
            stroke(148, 148, 148);
            line(0, this.height/2, this.width, this.height/2);
            line(this.width/2, 0, this.width/2, this.height);
            
            strokeWeight(2);
            stroke(0, 173, 23);
            
            
            var f1 = {
                lines:true,
                pts:false,
                thick1:2,
                thick2:0.3,
                moveX:0,
                moveY:0,
                fun: function(x){
                    return 100*sin(x+this.moveX)+this.moveY;
                },
                minX:-200,
                maxX:200,
                done:false
            };
            var f2 = {
                lines:true,
                fun: function(x){
                    return 100*cos(x);
                },
                minX:-200,
                maxX:200,
                done:false
            };
            
            /**Add two defined functions (this adds f1 to f2)**/
            var f3 = {
                lines:true,
                moveX:0,
                moveY:0,
                fun: function(x){
                    return f1.fun(x+this.moveX)+f2.fun(x+this.moveX)+this.moveY;
                },
                minX:-200,
                maxX:200,
                done:false
            };
            
            /*****Graph list of points (from negative 400 to postive 400)****/
            var p1 = {
                arrX:[1, 2, 3, 4, 5, 6, 7,  8,  9, 11],
                arrY:[0, 1, 1, 2, 3, undefined, 8, 13, 21, 34], 
                lines:true,
                fun: function(x){
                    return this.arrY[this.arrX.indexOf(x)];
                },
                minX:-200,
                maxX:200,
                done:false,
            };
            
            /*****Fibonacci Sequence from x=0 to x=500*****/
            var Fibo = {
                thick1:5,
                thick2:0.5,
                lines:true,
                
                fun: function(x){
                    var Phi =(1+sqrt(5))/2; 
                    var phi2=(1-sqrt(5))/2;  
                    return (pow(Phi,x) - pow(phi2,x))/sqrt(5);
                },
                minX:0,
                maxX:200,
                done:false,
                by:1
            };
            
            /*****Original Code*****/
            /*
                    y = -100 * tan(x*x);
                    strokeWeight(2);
                    point(x + 200, y + 200);
                    strokeWeight(0.5);
                    line(x+200,200+-100 * tan(pow(x-0.5,2)),x + 200, y + 200);
                    x += 0.5;
            */
            
            var graph = function(funct,origin) {
                pushMatrix();
                translate(origin[0],origin[1]);
                if(funct.fun!==undefined && funct.done === false){
                    if(funct.by===undefined){funct.by=10;}
                    for(var x =funct.minX;x<funct.maxX;x+=funct.by){
                        if(funct.fun(x)!==undefined){
                            var y = funct.fun(x);
                            strokeWeight(funct.thick1||3);
                            if((funct.pts===undefined||funct.pts===true) && (y<this.height/2 && y>-this.height/2)){point(x, -y);}
            
                            strokeWeight(funct.thick2||0.5);
                            if(funct.lines===true && (y<this.height/2 && y>-this.height/2)){if(funct.by>0){line(x-funct.by,-funct.fun(x-funct.by),x,-y);}}
                        }
                   }
                   funct.done=true;
                }
                popMatrix();
            };
            
            var RED = color(255,0,0);
            var BLUE = color(0,0,255);
            var GREEN = color(0,255,0);
            var dORIGIN = [this.width/2,this.height/2];
                fill(255, 255, 255,360);
                rect(0,0,this.width,this.height);
                stroke(BLUE);
                graph(f1,dORIGIN);
                
                stroke(RED);
                graph(f2,dORIGIN);
                
                stroke(GREEN);
                graph(f3,dORIGIN);
                
                stroke(color(0, 225, 255));
                graph(Fibo,dORIGIN);
            }
    }
});
var win2 = new window({
    hei: 100,
    winX:200,
    winY:200,
    width:(width),
    height:(height),
    format: function() {
        topText(this,["Bookmarklet","by Nate"]);
        fill(201, 255, 250,160); stroke(0,0,0); strokeWeight(0.5);
    },
    program: function(aFun){
        aFun();
        if(this.runtimes===0){
            fill(0, 0, 0,360);
            rect(0,0,this.width,this.height);
            this.snaps=false;
        }
        if(this.snap){
            image(this.snap,0,0,this.width,this.height);
        }
        var DI = function(x,y,c){
            switch(c){
            case 1: image(getImage("avatars/leaf-blue"),x,y,30,30); break;
            case 2: image(getImage("avatars/leaf-green"),x,y,30,30);break;
            case 3: image(getImage("avatars/leaf-red"),x,y,30,30); break;
            case 4: image(getImage("avatars/leaf-yellow"),x,y,30,30);break;
            
            }
            
        };
        var DIL = 30; 
        var R = this.runtimes; 
        var x1 = 2; 
        var y1 = 3; 
        var x2 = 20; 
        var y2 = 20; 
        var x3 = 1.6; 
        var y3 = 0.24; 
        var x4 = 150; 
        var y4 = 150; 
        var x5 = 150; 
        var y5 = 200;
        fill(255, 255, 255);
        rect(0,0,this.width,this.height);
        for (var i = 0; i < DIL; i++) { 
          DI((sin(R * x1 + i * x2 + x3) * x4 + x5),(cos(R * y1 + i * y2 + y3) * y4 + y5),1);
          DI((sin(R * x1 + i * x2 + x3) * -x4 + x5),(cos(R * y1 + i * y2 + y3) * y4 + y5),2);
        }
    }
});
var win3 = new window({
    paused:{minimized:true},
    width:400,
    height:400,
    format: function() {
        topText(win3,"Benchmark Window",color(0),0.96);
        fill(239, 255, 115,160); stroke(0,0,0); strokeWeight(0.5);
    },
    program : function() {
        fill(255, 255, 255);
        rect(0,0,this.width,this.height);
        textSize(29);
        textAlign(CENTER,CENTER);
        fill(255, 0, 0);
        
        text("Windows are paused when minimized :-)\n\u26fa\n"+this.runtimes,0,0,this.width,this.height);
        textSize(12);
        textAlign(LEFT,TOP);
    }
});
var win4 = new window({
    format: function() {
        topText(this,["Space Path","by Will Early"],color(0),0.96);
        fill(239, 255, 115,160); stroke(0,0,0); strokeWeight(0.5);
    },
    program: function(){
        /**Space Path Vars*/
        var cool = this.variables.cool||0; // Try it out :D
        var boundaries = this.variables.boundaries|| 0; // Show orbital boundaries
        var paths = this.variables.paths||0; // Show orbital paths
        var trail = this.variables.trail||1; // Show lunar trail
        var fade = this.variables.fade||1; // Fade the lunar trail
        var slow = this.variables.slow||250; // Animation speed reduction
        var steps = this.variables.steps||1000; // How many points to plot
        var precision = this.variables.precision||0.4; // Plotting precision
        var centre = {
            x: 200,
            y: 200
        };
        var distances = {
            EarthSun: 150,
            MoonEarth: 38
        };
        var orbital_periods = {
            Earth: 365,
            Moon: 27
        };
        var orbital_velocities = {
            Earth: 360 / orbital_periods.Earth,
            Moon: 360 / orbital_periods.Moon
        };
        var delta_t = this.variables.delta_t||0;
        var time = this.variables.time||0;
        var images = {
            Sun: getImage("cute/Star"),
            Earth: getImage("space/planet")
        };
        var plot = function(count, precision, weight) {
            var before = time;
            var new_weight = weight;
            var j = -1,
                k = 0;
            // j, k and c are used to fade the colour
        
            for(var i = count; i > 0; i--) {
                time += precision * i / count;
                new_weight = weight * (1 - i / count);
                strokeWeight(new_weight);
                if(new_weight > 1) {
                    if(fade) {
                        if(j === -1) {
                            j = 0;
                            k = count - i;
                        }
                        var c = round(1.5 * 255 * ((j++) / k) ^ 2);
                        stroke(c, c, c);
                    }
        
                    point(centre.x + distances.EarthSun * cos(orbital_velocities.Earth * time) + distances.MoonEarth * cos(orbital_velocities.Moon * time), centre.y + distances.EarthSun * sin(orbital_velocities.Earth * time) + distances.MoonEarth * sin(orbital_velocities.Moon * time));
                }
            }
            return time - before;
        };
        var orbit = function(centre, radius, weight) {
            strokeWeight(weight);
            ellipse(centre.x, centre.y, 2 * radius, 2 * radius);
        };
        var spacepath = function() {
		// time = 0; // debug mode 
		var oldCentre;

		if(cool) {
			oldCentre = centre;
			centre = {
				x: 200 - (distances.EarthSun * cos(orbital_velocities.Earth * time) + distances.MoonEarth * cos(orbital_velocities.Moon * time)),
				y: 200 - (distances.EarthSun * sin(orbital_velocities.Earth * time) + distances.MoonEarth * sin(orbital_velocities.Moon * time))
			};
		}

		noFill();
		strokeWeight(0.5);
		bckgrnd(color(0, 0, 0),win4);
		stroke(212, 148, 148);

		var positions = {
			Sun: centre,
			Earth: {
				x: centre.x + distances.EarthSun * cos(orbital_velocities.Earth * time),
				y: centre.y + distances.EarthSun * sin(orbital_velocities.Earth * time)
			}
		};

		if(boundaries) {
			orbit(positions.Sun, distances.EarthSun + distances.MoonEarth, 0.125);
			orbit(positions.Sun, distances.EarthSun - distances.MoonEarth, 0.125);
		}

		if(paths) {
			stroke(86, 152, 209);
			orbit(positions.Sun, distances.EarthSun, 1);
			stroke(233, 237, 245);
			orbit(positions.Earth, distances.MoonEarth, 0.5);
		}

		strokeWeight(44);
		fill(255, 255, 0);
		stroke(255, 255, 0);
		//point(positions.Sun.x, positions.Sun.y);
		image(images.Sun, positions.Sun.x - 33, positions.Sun.y - 68, 67, 114);
		text("Sun", positions.Sun.x - 10, positions.Sun.y + 44);

		strokeWeight(10);
		fill(0, 123, 255);
		stroke(0, 123, 255);
		point(positions.Earth.x, positions.Earth.y);
		image(images.Earth, positions.Earth.x - 5, positions.Earth.y - 5, 12, 12);
		text("Earth", positions.Earth.x - 14, positions.Earth.y + 16);

		stroke(255, 255, 255);
		if(trail) {
			time -= (1 - 1 / slow) * delta_t; // rewind time
			delta_t = plot(steps, precision, 2);
		} else {
			time += (steps * precision) / (2.5 * slow);
			strokeWeight(4);
			point(centre.x + distances.EarthSun * cos(orbital_velocities.Earth * time) + distances.MoonEarth * cos(orbital_velocities.Moon * time), centre.y + distances.EarthSun * sin(orbital_velocities.Earth * time) + distances.MoonEarth * sin(orbital_velocities.Moon * time));
		}

		positions.Earth = {
			x: centre.x + distances.EarthSun * cos(orbital_velocities.Earth * time),
			y: centre.y + distances.EarthSun * sin(orbital_velocities.Earth * time)
		};

		positions.Moon = {
			x: positions.Earth.x + distances.MoonEarth * cos(orbital_velocities.Moon * time),
			y: positions.Earth.y + distances.MoonEarth * sin(orbital_velocities.Moon * time)
		};

		fill(255, 255, 255);
		stroke(168, 168, 168);
		strokeWeight(7);
		point(positions.Moon.x, positions.Moon.y);
		text("Moon", positions.Moon.x - 15, positions.Moon.y + 14);

		if(cool) {
			centre = oldCentre;
		}
		noStroke();
	};
        spacepath();
		this.yar("cool",cool); 
        this.yar("boundaries",boundaries);
        this.yar("paths",paths);
        this.yar("trail",trail); 
        this.yar("fade",fade); 
        this.yar("slow",slow); 
        this.yar("steps",steps); 
        this.yar("precision",precision);
        this.yar("delta_t",delta_t);
        this.yar("time",time);
    
}
});
var win5_Once=false;
var win5 = new window({
    format: function() {
        topText(this,["Preview","by "],color(0),1);
        this.icon=getImage("avatars/aqualine-seed");
        fill(239, 255, 115,160); stroke(0,0,0); strokeWeight(0.5);
    },
    program : function() {
        
        var x = this.variables.x||0;
        if(!win5_Once){
            var m = new window({
            format: function() {
                topText(this,["Your app here!","by You "],color(0),0.96);
                fill(117, 140, 255,160); stroke(0,0,0); strokeWeight(0.5);
                }, 
            program: function(){
                bckgrnd(color(82, 226, 255,180),m);
            }
            }
            );
            win5_Once=true;
        }
        textSize(29);
        textAlign(CENTER,CENTER);
        bckgrnd(color(255, 255, 255,180),win5);
        fill(0);
        text("New apps are needed!\n\nInvite friends over to post links to your own or another's apps!\n\u26fa\n"+x,0,0,this.width,this.height);
        textSize(12);
        textAlign(LEFT,TOP);
        x++;
        this.yar("x",x);
        
    }
});
/*var win6 = new window({
    format: function() {
        topText(this,["Avatar Game","by T#1SPP"],color(0),1);
        fill(21, 255, 0,160); stroke(79, 163, 0); strokeWeight(0.5);
    },
    program : function() {
        var FF = !1;
        var TT = !0;
        var xfx='';
        var scene = this.variables.scene || 0;
        var introColour = this.variables.introColour || 100;
        var introColour2 = this.variables.introColour2 || 0;
        var introColourChange = this.variables.introColourChange || 5;
        var scan = this.variables.scan || 0;
        var scanTime = this.variables.scanTime || 0;
        var character = this.variables.character || 1;
        var news = this.variables.news || "";
        var roopy = this.variables.roopy || getImage("seasonal/hopper-reindeer");
        var virus = this.variables.virus || getImage("seasonal/father-winston");
        var robot = this.variables.robot || getImage("seasonal/hopper-partying");
        var aFont = this.variables.aFont || createFont("Space Age");
        textFont(aFont);
        var death = this.variables.death || false;
        var obX = this.variables.obX || 200;
        var obY = this.variables.obY || 20;
        var yMove = this.variables.yMove || 0;
        var x = this.variables.x || 200;
        var y = this.variables.y || 300;
        var face = this.variables.face || 0;
        var shake = this.variables.shake || 0;
        var moveAble = this.variables.moveAble || true; //character movability
        var timeStop = this.variables.timeStop || 0; // delay time when obstacle reaches ground
        var subTime = this.variables.subTime || 0.1; // time delay before obstacle moves
        var num = this.variables.num || 0; //choose random number for obstacle location
        var leftMove = this.variables.leftMove || false;
        var rightMove = this.variables.rightMove || false;
        var wait = this.variables.wait || 5;   //time for each stage
        var timeSet = this.variables.timeSet || false;
        var stage = this.variables.stage || 1;
        var colour1 = this.variables.colour1 || 400;
        var colour2 = this.variables.colour2 || 400;
        var colour3 = this.variables.colour3 || 400;
        var colour4 = this.variables.colour4 || 400;
        var highScores = this.variables.highScores || ["T#1SPP------------------------------------22"];

        var Logo = function (a, b) {
                this.x = a;
                this.y = b;
                strokeWeight(1);
                stroke(0, 0, 0);
            },
            particles = function (a, b, c) {
                this.x = a;
            },
            particles = function (a, b, c) {
                this.x = a;
                this.y = b;
                this.move = c;
            };
        particles.prototype.draw = function () {
            noStroke();
            fill(0, 225, 255);
            rect(this.x + shake, this.y + shake, 5, 5);
        };
        for (var mist = [], i = 0; 20 > i; i += 1) {
            mist.push(new particles(random(0, 400), random(0, 400), random(-0.5, 0.5)));
        }
        var intro = function () {
                bckgrnd(color(0, 212, 0),win6);
                for (var a = 0; 20 > a; a += 1) {
                    stroke(0, 255, 9, introColour - 10 * a); strokeWeight(6); 
                    xfx= (-6 * a + scan>0&&-6 * a + scan<400)&&line(-6 * a + scan, 0, -6 * a + scan, 400);
                    scan += 0.25; xfx= (500 <= scan) && (scan = -100, a = 0);
                }
                textAlign(CENTER, CENTER);
                fill(255, 0, 0);
                textSize(40);
                text("The Avatar Game", 200, 120);
                introColour2 += introColourChange;
                image(getImage("seasonal/hopper-partying"), 135, 175);
                textSize(15);
                text("Holiday Special EXTENDED!", 200, 75);
                text("Click Anywhere!!", 200, 160);
                Logo(200, 245);
                xfx=270 < introColour2 && (introColourChange = -5, scanTime += 1);
                xfx=10 > introColour2 && (introColourChange = 5);
                xfx=400 <= introColour2 && textSize(20);
                xfx=3 <= scanTime && (introColourChange = 400);
            },
            scene1 = function () {
                scene = 1;
                bckgrnd(color(0),win6);
                noFill();
                strokeWeight(10 + random(1, 10));
                stroke(0, 115, 255);
                rect(0, 0, 400, 400);
                fill(255, 0, 0);
                textSize(40);
                textAlign(CENTER, CENTER);
                text("The Avatar Game", 200, 50);
                fill(255, 0, 0);
                textSize(30);
                text("Holiday Special EXTENDED!", 200, 116);
                noFill();
                strokeWeight(colour1);
                stroke(255, 0, 0);
                rect(150, 150, 100, 50, 5);
                fill(255, 0, 0);
                textSize(20);
                text("Play", 200, 175);
                colour1 = 150 < mouseX && 250 > mouseX && 150 < mouseY && 200 > mouseY ? random(3, 6) : 3;
                noFill();
                strokeWeight(colour2);
                stroke(255, 0, 0);
                rect(150, 220, 100, 50, 5);
                fill(255, 0, 0);
                textSize(11.9);
                text("Holiday Special", 200, 245);
                colour2 = 150 < mouseX && 250 > mouseX && 220 < mouseY && 270 > mouseY ? random(3, 6) : 3;
                noFill();
                strokeWeight(colour3);
                stroke(255, 0, 0);
                rect(150, 290, 100, 50, 5);
                fill(255, 0, 0);
                textSize(20);
                text("Scores", 200, 315);
                colour3 = 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY ? random(3, 6) : 3;
                for (var a = 0; a < mist.length; a += 1) {
                    mist[a].draw(); mist[a].y += 0.25;xfx= 410 < mist[a].y && (mist[a].y = -5); mist[a].x += mist[a].move;xfx= 0 > mist[a].x && (mist[a].x = 400);xfx= 400 < mist[a].x && (mist[a].x = 0);
                }
            },
            scene2 = function () {
                scene = 2;
                xfx= (timeSet===true) && (wait = 5, timeStop = 0, subTime -= 0.003, num = round(random(0, 7)), obX = 50 * num, obY = 20, timeSet = FF);
                bckgrnd(color(0),win6);
                fill(0, 78, 173);
                strokeWeight(5);
                stroke(0, 255, 68);
                rect(0 + shake, 325 + shake, 400, 75);
                xfx = (character===1 && death === FF) ? (imageMode(CENTER), image(roopy, x + 25, y + 7, 40, 40), noFill(), stroke(0, 0, 0), strokeWeight(2)) : 2 === character && FF === death ? (imageMode(CENTER), image(virus, x + 25, y + 7, 40, 40), noFill(), stroke(0, 0, 0), strokeWeight(2)) : 3 === character && FF === death && (imageMode(CENTER), image(robot, x + 25, y + 7, 50, 50));
                strokeWeight(3);
                stroke(21, 255, 0);
                fill(0, 25, 148);
                rect(obX - 410 + shake, obY - 300 + shake, 400, 320, 10);
                rect(obX + 60 + shake, obY - 300 + shake, 400, 320, 10);
                fill(4, 0, 133);
                rect(obX - 200 + shake, obY - 300 + shake, 100, 320, 10);
                rect(obX + 150 + shake, obY - 300 + shake, 100, 320, 10);
                wait += subTime;
                xfx = 0 > wait && 300 > obY ? (yMove = 10, shake = random(-5, 5)) : shake = yMove = 0;
                xfx =280 < obY && (timeStop += 1);
                xfx =60 <= timeStop && FF === death && (stage += 1, timeSet = TT);
                fill(255, 0, 0);
                obY += yMove;
                xfx =TT === leftMove && 0 < x && TT === moveAble && FF === death && 300 !== obY && (x += -50, moveAble = FF);
                xfx =TT === rightMove && 350 > x + 25 && TT === moveAble && FF === death && 300 !== obY && (x += 50, moveAble = FF);
                if (x < obX && obY + 50 > y || x + 25 > obX + 60 && obY + 50 > y) {
                    death = TT;
                }
                fill(255, 0, 0);
                textSize(30);
                textAlign(CENTER, CENTER);
                text("Level: " + stage, 200 + shake, 350 + shake);
                for (var a = 0; a < mist.length; a += 1) {
                    mist[a].draw(); mist[a].y += 0.25; xfx = 410 < mist[a].y && (mist[a].y = -5); mist[a].x += mist[a].move;xfx = 0 > mist[a].x && (mist[a].x = 400);xfx = 400 < mist[a].x && (mist[a].x = 0);
                }
                xfx =TT === death && (fill(255, 0, 0, 150), rect(-5, -5, 410, 410), fill(0, 145, 255), textSize(50), text("", 200, 100), textSize(30), text("Score: " + stage + "", 200, 200), noFill(), strokeWeight(colour1), stroke(13, 255, 0), rect(120, 300, 160, 60, 10), fill(0, 255, 9), text("Menu", 200, 330), colour1 = 120 < mouseX && 280 > mouseX && 300 < mouseY && 360 > mouseY ? random(3, 6) : 0);
            },
            scene3 = function () {
                scene = 3;
                bckgrnd(color(0),win6);
                noFill();
                strokeWeight(10 + random(1, 10));
                stroke(0, 115, 255);
                rect(0, 0, 400, 400);
                fill(255, 255, 0);
                textSize(30);
                textAlign(CENTER, CENTER);
                text("Choose Your Avatar!", 200, 60);
                stroke(255, 0, 0);
                strokeWeight(3 + colour1);
                noFill();
                rect(30, 100, 100, 120);
                stroke(255, 0, 0);
                strokeWeight(3 + colour2);
                noFill();
                rect(150, 100, 100, 120);
                stroke(255, 0, 0);
                strokeWeight(3 + colour3);
                noFill();
                rect(270, 100, 100, 120);
                imageMode(CENTER);
                image(virus, 200, 160, 70, 70);
                noFill();
                stroke(0, 0, 0);
                strokeWeight(2);
                image(robot, 320, 160, 70, 70);
                imageMode(CENTER);
                image(virus, 200, 160, 70, 70);
                noFill();
                stroke(0, 0, 0);
                strokeWeight(2);
                image(roopy, 75, 160, 70, 70);
                xfx =1 === character && (news = "Reindeer Hopper.  He is the most balanced avatar you can get in the game.");
                xfx =2 === character && (news = "Father Winston.  Heavy and slow, this Winston packs a big punch, but it is hard to use.");
                xfx =3 === character && (news = "Partying Hopper.  He is light and fast but weak.");
                colour1 = 1 === character ? 5 : 0;
                colour2 = 2 === character ? 5 : 0;
                colour3 = 3 === character ? 5 : 0;
                textSize(16);
                textAlign(CENTER, CENTER);
                fill(21, 255, 0);
                text(news, 30, 190, 340, 150);
                face = 1 === character ? random(-1, 1) : 0;
                x = 55;
                y = 150;
                noFill();
                stroke(0, 255, 38);
                strokeWeight(colour4);
                rect(150, 320, 100, 50, 5);
                fill(51, 255, 0);
                textSize(20);
                text("Play", 200, 345);
                colour4 = 150 < mouseX && 250 > mouseX && 320 < mouseY && 370 > mouseY ? random(3, 6) : 3;
                for (var a = 0; a < mist.length; a += 1) {
                    mist[a].draw(); mist[a].y += 0.25;xfx = 410 < mist[a].y && (mist[a].y = -5); mist[a].x += mist[a].move;xfx = 0 > mist[a].x && (mist[a].x = 400);xfx = 400 < mist[a].x && (mist[a].x = 0);
                }
            },
            scene4 = function () {
                scene = 4;
                bckgrnd(color(0),win6);
                noFill();
                strokeWeight(10 + random(1, 10));
                stroke(0, 115, 255);
                rect(0, 0, 400, 400);
                textAlign(CENTER, CENTER);
                textSize(30);
                fill(255, 0, 0);
                text("It's The Holiday", 30, -27, 340, 250);
                text("Special!!!  Party all", 30, 7, 340, 250);
                text("YEAR long with crazy", 30, 40, 340, 250);
                text("updates!", 30, 70, 340, 250);
                noFill();
                strokeWeight(colour3);
                stroke(255, 0, 0);
                rect(150, 290, 100, 50, 5);
                fill(255, 0, 0);
                textSize(20);
                text("Menu", 200, 315);
                colour3 = 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY ? random(3, 6) : 3;
                for (var a = 0; a < mist.length; a += 1) {
                    mist[a].draw(); mist[a].y += 0.25;xfx = 410 < mist[a].y && (mist[a].y = -5); mist[a].x += mist[a].move; xfx = 0 > mist[a].x && (mist[a].x = 400);xfx = 400 < mist[a].x && (mist[a].x = 0);
                }
            },
            scene5 = function () {
                scene = 5;
                bckgrnd(color(0), win6);
                noFill();
                strokeWeight(10 + random(1, 10));
                stroke(0, 115, 255);
                rect(0, 0, 400, 400);
                fill(255, 0, 0);
                textSize(40);
                text("Leaderboards", 200, 50);
                noFill();
                strokeWeight(colour3);
                stroke(255, 0, 0);
                rect(150, 290, 100, 50, 5);
                fill(255, 0, 0);
                textSize(20);
                text("Menu", 200, 315);
                colour3 = 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY ? random(3, 6) : 3;
                for (var a = 0; a < highScores.length; a += 1) {
                    textSize(20); text(highScores[a], 200, 30 * a + 100);
                }
                for (a = 0; a < mist.length; a += 1) {
                    mist[a].draw(); mist[a].y += 0.25;xfx = 410 < mist[a].y && (mist[a].y = -5); mist[a].x += mist[a].move;xfx = 0 > mist[a].x && (mist[a].x = 400);xfx = 400 < mist[a].x && (mist[a].x = 0);
                }
            },
            title = function () {
                scene = -1;
                bckgrnd(color(60, 0, 117),win6);
                noFill();
                strokeWeight(10 + random(1, 10));
                stroke(0, 115, 255);
                rect(0, 0, 400, 400);
                textSize(40);
                textAlign(CENTER, CENTER);
                fill(21, 255, 0);
                text("The Avatar Game", 200, 50);
                strokeWeight(10);
                stroke(0, 0, 0);
                fill(255, 241, 153);
                rect(50, 120, 300, 250, 40);
                ellipse(140, 230, 20, 20);
                ellipse(260, 230, 20, 20);
                arc(200, 340, 200, 100, 180, 360);
                fill(135, 74, 0);
                rect(40, 90, 320, 100, 20);
            };
        
        this.xdraw = function () {pushMatrix();
            translate(this.winX+3,this.winY+3+this.btnSize);
            scale((this.wid-6)/this.width,(this.hei-6)/this.height);
            xfx = 0 === scene ? intro() : 1 === scene ? scene1() : 2 === scene ? scene2() : 3 === scene ? scene3() : 4 === scene ? scene4() : 5 === scene ? scene5() : -1 === scene && title();
            popMatrix();
        };
        this.yar("xdraw",this.xdraw);
        this.variables.xdraw();
        
        KHANFLICT.mouseClicked= function () {
            xfx =0 === scene ? scene = 1 : 1 === scene ? 150 < mouseX && 250 > mouseX && 150 < mouseY && 200 > mouseY ? (death = FF, scene3()) : 150 < mouseX && 250 > mouseX && 220 < mouseY && 270 > mouseY ? scene4() : 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY && scene5() : 2 === scene ? 120 < mouseX && 280 > mouseX && 300 < mouseY && 360 > mouseY && TT === death && scene1() : 3 === scene ? 30 < mouseX && 130 > mouseX && 100 < mouseY && 220 > mouseY ? character = 1 : 150 < mouseX && 250 > mouseX && 100 < mouseY && 220 > mouseY ? character = 2 : 270 < mouseX && 370 > mouseX && 100 < mouseY && 220 > mouseY ? character = 3 : 150 < mouseX && 250 > mouseX && 320 < mouseY && 370 > mouseY && (x = 200, y = 300, stage = 1, wait = 5, subTime = -0.1, obX = 200, obY = 20, death = FF, yMove = 0, timeSet = FF, timeStop = 0, scene2()) : 4 === scene ? 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY && scene1() : 5 === scene && 150 < mouseX && 250 > mouseX && 290 < mouseY && 340 > mouseY && scene1();
        };
        this.yar("mouseClicked",this.mouseClicked);
        
        KHANFLICT.keyPressed = function () {
            xfx = keyCode === LEFT ? leftMove = TT : keyCode === RIGHT ? rightMove = TT : keyCode === UP && 1 === scene && title();
        };
        this.yar("keyPressed",this.keyPressed);
        
        KHANFLICT.keyReleased = function () {
            xfx =keyCode === LEFT && (leftMove = FF, moveAble = TT);
            xfx =keyCode === RIGHT && (rightMove = FF, moveAble = TT);
        };
        this.yar("keyReleased",keyReleased);
        
        
    }
});
*/
var mouse= function() {
    cursor("none");
    strokeWeight(0.5);
    stroke(255, 255, 255);
    fill(0, 0, 0);    
    beginShape();
    vertex(mouseX,mouseY);
    vertex(mouseX,mouseY+20);
    vertex(mouseX+5,mouseY+10);
    vertex(mouseX+8,mouseY+15);
    vertex(mouseX+15,mouseY+20);
    endShape(CLOSE);
};
var onceOnly=true;
var snapshot = get(0,0,400,400);
var clicked=false;
mouseReleased=function() {
    clicked=false;
    onceOnly=true;
};
var grad = function(from, to) {
    for (var i = 0; i < height / 3; i++) {
        strokeWeight(4);
        stroke(lerpColor(from, to, i / (height / 3)));
        line(0, i * 3, width, i * 3);
    }
};
var background2 = function() {
    grad(color(255, 255, 255), color(0, 221, 255));
    noStroke();
    fill(0, 109, 242);
    rect(-2, 265, 411, 137);
    fill(240, 240, 19);
    rect(20, 20, 87, 87);
    fill(239, 250, 85);
    rect(27, 27, 75, 75);
    fill(252, 252, 156);
    rect(39, 38, 50, 50);
    fill(89, 89, 89);
    rect(0, 202, 400, 61);

    fill(240, 240, 19);
    rect(20, 355, 87, 87);
    fill(239, 250, 85);
    rect(27, 361, 75, 75);
    fill(252, 252, 156);
    rect(39, 372, 50, 50);
    fill(89, 89, 89);


    rect(-2, 204, 53, -60);
    rect(55, 202, 42, -126);
    rect(102, 226, 42, -126);
    rect(140, 265, 64, -72);
    rect(154, 223, 50, -189);
    rect(55, 190, 42, -126);
    rect(81, 230, 42, -48);
    rect(207, 213, 54, -165);
    rect(268, 206, 42, -126);
    rect(300, 221, 50, -96);
    rect(255, 262, 42, -79);
    rect(365, 228, 42, -126);
    fill(64, 63, 64);

    rect(-29, 234, 461, 35);
    rect(-2, 321, 53, -60);
    rect(55, 373, 42, -126);
    rect(102, 361, 42, -126);
    rect(140, 306, 64, -72);
    rect(154, 387, 50, -137);
    rect(55, 376, 42, -126);
    rect(81, 285, 42, -48);
    rect(207, 370, 54, -135);
    rect(268, 348, 42, -105);
    rect(300, 311, 50, -68);
    rect(255, 314, 42, -79);
    rect(365, 368, 42, -126);
};
var winds = function(arr){
    var sFn  = function(a, b){
        if(a.name < b.name){ return -1;}
        if(a.name > b.name){ return 1 ;}
        else {return 0;}
    };
    return arr.sort(sFn);
};
var selectedWin=[];
var m=false;
var appsPR=floor(width/400*5);
var windowHover=false;
var draw2= function() {
    background(255, 255, 255);
    popMatrix();
    popMatrix();
    image(snapshot,0,0,width,height);
    var keys = Object.keys(windows);
    var keyL=keys.length;
    fill(255, 255, 255,180);
    rect(20,20,width-40,height-40);
    var WINDOWSTORAGE= winds(windows.slice());
        
        for (var i = 0; i < WINDOWSTORAGE.length; i++) {
                pushMatrix();
                
                var shelf = (i-i%appsPR)/appsPR;
                WINDOWSTORAGE[i].format();
                rect(75*shelf+45,25 + (i-appsPR*shelf)*64, 32, 32, 5);
                if(WINDOWSTORAGE[i].icon){
                    image(WINDOWSTORAGE[i].icon,75*shelf+45,25 + (i-appsPR*shelf)*64,31,31);
                }
                noStroke();
                fill(255);
                
                rect(75*shelf+45+20,25 + (i-appsPR*shelf)*64+20,0,0.1,-10);
                fill(0, 0, 0);
                textAlign(CENTER, BOTTOM);
                textSize(11);
                text(WINDOWSTORAGE[i].name||Object.keys(WINDOWSTORAGE)[i], 75*shelf+55/4+20,25-(75-67) + (i-appsPR*shelf)*64+40, 55, 39);
        
            if (!windowHover&&mouseIn(75*shelf+45,25 + (i-appsPR*shelf)*64, 32, 32, 5) && !m&&!clicked && mouseIsPressed) {
                WINDOWSTORAGE[keys[i]].paused.minimized =!WINDOWSTORAGE[keys[i]].paused.minimized;
            }
            
        }
    
    if(mouseIsPressed){m=true;}else{m=false;}
    var oneWinHovered=false;
    for (var i = 0; i < keyL; i++) 
    { 
        windows[keys[i]].draw();
        oneWinHovered=oneWinHovered||windows[keys[i]].check(1);
        
        windowHover=oneWinHovered;
        if(mouseIsPressed){
            if(windows[keys[i]].check()){
                windowHover=false;
                if(!clicked){
                    windows[keys[i]].clicked=true;
                    selectedWin[0]=windows[keys[i]];
                    selectedWin[1]=keys[i];
                }
                clicked=true; //Only one window dragged at a time
            }
        }
        else{
            clicked=false;
        }
        
        if( windows[keys[i]].clicked&&!windows[keys[i]].paused.maximized){
            
            windows[keys[i]].winX-= ( windows[keys[i]].winX-mouseX+ windows[keys[i]].wid/2)/1.5;
            windows[keys[i]].winY-= ( windows[keys[i]].winY-mouseY+3)/1.5;
        }
        if(clicked===false){
            windows[keys[i]].clicked=false;
        }
        
        //Makes things easier:
            //If a window is selected move to back (last drawn) of 'windows' array
    }
    var keys = Object.keys(windows);
    
    if((clicked&& selectedWin!==undefined) &&onceOnly){
        if(selectedWin[0]){
            var temp = selectedWin[1];
            if(windows[temp]!==windows[keys[keyL]])
            {
                windows.splice(selectedWin[1], 1);
                windows.push(selectedWin[0]);
            }
        }
        onceOnly=false;
    }
    
    
    mouse();
    
};

var curDraw = function() { //executes once, then gets overwritten :-)
    background2();
    snapshot = get(0,0,400,400);
    textAlign(LEFT);
    fill(255, 255, 255);
    rect(0,0,width,height);
    fill(0, 0, 0);
    text("Loading"+Array(frameCount%10).join("."),width/2-width/15,height/2,width,height);
    if(frameCount>20){
        textAlign(CENTER);
        text("Have Fun! :-)",0,height/2+50,width,height);
    }
    if(frameCount>50){
        textAlign(LEFT);
        curDraw=draw2;
    }
};
draw= function() {
   curDraw(); 
};
